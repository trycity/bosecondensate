/**
 *@file JastrowConfig.h
 *
 *@author ikhan
 */

/*
Class used to create a jastrow configuration,
requires 1-body wavefunction due to external potential (Phi)
and 2-body interaction term(InteractionF).
localE, localEsqd are the local energy terms derived from the wavefunctions
*/

#ifndef _JASTROWCONFIG_H
#define _JASTROWCONFIG_H

#include <valarray>

#include "VMCconfig.h"
#include "Utilities/rand.h"
#include "Utilities/VMCPoint.h"

#include "Wavefunctions/Phi.h"
#include "Wavefunctions/InteractionF.h"
#include "Energy_Terms/localE.h"
#include "Energy_Terms/localESqd.h"

namespace QMC
{
  //template <typename Phi, typename InteractionF, typename localE, typename localESqd>
class JastrowConfig : public VMCconfig
{
public:
   JastrowConfig(unsigned NParticles, 
                 unsigned ndim, 
                 double ParticleRadius, 
                 const std::valarray<double>& BoxSize, 
                 const Phi& wfnPhi, 
                 const InteractionF& wfnF, 
                 const localE& LE, 
                 const localESqd& LESqd);
   //VMCconfig(NParticles, ndim, ParticleRadius, BoxSize), m_wfnPhi(wfnPhi), m_wfnF(wfnF), m_localEn(LE), m_localEnSqd(LESqd) {}
                   			
  ~JastrowConfig();
					
  void TrialMove(unsigned* pnWalked, VMCPoint& endPoint, double* pdq);
     /*   {
      /// pick one particle at random
      unsigned k = (unsigned)(ran2(m_Seed)*m_NParticles);
			
      /// this is the one to be moved
      *pnWalked = k;
			
      /// compute its distance to other particles
      std::valarray<double> rki(m_NParticles-1);
      for(unsigned i=0; i<k; i++)
      {
         rki[i] = VmcDistance(m_vPoints[k], m_vPoints[i]);
      }

      for(unsigned i=k+1; i<m_NParticles; i++)
      {
         rki[i-1] = VmcDistance(m_vPoints[k], m_vPoints[i]);
      }
			
      /// make a trial move and re-compute distances to other particles
      endPoint.resize(m_NDim);
      std::valarray<double> rkiT(m_NParticles-1);
      bool Accept = true;
      do
      {
         for(unsigned n=0; n<m_NDim; n++)
         {
       	    endPoint[n] = (ran2(m_Seed)-0.5)*m_BoxSize[n];
	 }
	 
         for(unsigned i=0; i<k; i++)
         {
	    rkiT[i] = VmcDistance(endPoint, m_vPoints[i]);
	    if(rkiT[i] < m_radius0)
            {
	       Accept = false;
	       break;
	    }
	 }

         if(Accept)
         {
            for(unsigned i=k+1; i<m_NParticles; i++)
            {
	       rkiT[i-1] = VmcDistance(endPoint, m_vPoints[i]);
	       if(rkiT[i-1] < m_radius0)
               {
	          Accept = false;
	          break;
	       }
	    }
	 }
      }while(!Accept);

      double w=1.0;
      w *= m_wfnPhi(endPoint)/m_wfnPhi(m_vPoints[k]);
      for(unsigned i=0; i<m_NParticles; i++)
      {
         w *= m_wfnF(rkiT[i])/m_wfnF(rki[i]);
      }
			
      *pdq = w*w;
      }*/
		
  void Move(unsigned k, const VMCPoint& newPoint, bool bComputeE);
  /* {			
      m_vPoints[k] = newPoint;
      
      if(bComputeE && k<m_MaxCorrelation)
      {
         ComputeEnergy();
	 ComputeEnergySqd();
      }
      }*/
	
protected:

  double ComputeEnergy();
     /* {
      m_Energy = m_localEn(m_vPoints);
      m_EnergyComputed = true;
			
      return m_Energy;
      }*/
		
  double ComputeEnergySqd();
     /* {
      m_EnergySqd = m_localEnSqd(m_vPoints);
      
      return m_EnergySqd;
      }	*/
					
   Phi m_wfnPhi;
   InteractionF m_wfnF;
   localE m_localEn;
   localESqd m_localEnSqd;
   static const unsigned m_MaxCorrelation = 3;		
};
}; // end of namespace

#endif
